import numpy as np

from .processor import Processor


class Power(Processor):
    def __init__(self, n, users, fo):
        super().__init__(n, users, fo)
        self.ee = None

    def calibrate(self, est_dist):
        estimates = np.copy(est_dist)
        domain_size = len(estimates)
        n = self.n
        print('transfer ee in power: ', self.ee)
        var = 4 * self.ee / (self.ee - 1) ** 2
        var = var * n
        # fit power-law
        est_mean = np.mean(estimates)
        n_list = np.arange(1, n + 1, dtype=float)
        if est_mean < 1:
            alpha = 1.01
        else:
            alpha = self.search_alpha(est_mean, n_list)

        result = np.copy(estimates)
        for i in range(len(result)):
            ps = 0
            pf = 0
            pfhat = 0
            temp = 0
            k_list = np.arange(1, n + 1)
            tmp_var = np.exp(-(result[i] - k_list) ** 2 / (2 * var))
            tmp_var[tmp_var == 0] = 1e-32
            ps = 1 / np.sqrt(2 * np.pi * var) * tmp_var
            pf = 1 / k_list ** alpha / (np.sum(1 / x ** alpha for x in range(1, n + 1)))
            j_list = np.arange(1, n + 1)
            tmp_var = np.exp(-(result[i] - j_list) ** 2 / (2 * var))
            tmp_var[tmp_var == 0] = 1e-32
            pfhat = np.sum(1 / j_list ** alpha / (np.sum(1 / x ** alpha for x in range(1, n + 1))) * (
                        1 / np.sqrt(2 * np.pi * var) * tmp_var))
            print(tmp_var)
            print('ps: ', ps)
            print('pf: ', pf)
            print('j_list: ', j_list)
            print('pfhat: ', pfhat)
            temp = np.sum(k_list * ps * pf / pfhat)
            print('temp: ', temp)
            result[i] = temp
        return result

    @staticmethod
    def power_mean(n_list, alpha):
        return np.sum(n_list ** (1 - alpha)) / np.sum(n_list ** (0 - alpha))

    def search_alpha(self, est_mean, n_list):
        
        alpha = 2
        while self.power_mean(n_list, alpha) > est_mean:
            alpha *= 2

        r = 0
        h = alpha
        l = alpha / 2
        alpha = (h + l) / 2
        fit_mean = self.power_mean(n_list, alpha)
        while np.fabs(fit_mean - est_mean) > 0.01:
            if fit_mean > est_mean:
                l = alpha
            else:
                h = alpha
            alpha = (h + l) / 2
            fit_mean = self.power_mean(n_list, alpha)
            if r > 1000:
                break
            r += 1
        return alpha